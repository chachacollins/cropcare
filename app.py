import streamlit as st
import csv
import io
from z3 import *
import pandas as pd
import altair as alt # Import Altair

# CONFIGURATION
# Set a proper icon and page title
st.set_page_config(page_title="Crop Care Knowledge Base", page_icon="üå±", layout="wide")
st.title("Crop Care")
st.markdown("---")

# LOAD KNOWLEDGE BASE (Z3 Logic)
@st.cache_resource
def load_kb():
    # Initialize Z3 Fixedpoint Engine
    fp = Fixedpoint()
    fp.set(engine='datalog') 
    Thing = BitVecSort(32)
    
    # ID Helpers
    str_to_id = {}
    id_to_str = {}
    counter = 1

    def get_id(text):
        nonlocal counter
        if not text: return None
        # Clean text for consistent ID generation (lowercase is key for Z3 ID)
        clean = text.strip().strip("'").strip('"').lower() 
        if clean not in str_to_id:
            val = BitVecVal(counter, Thing)
            str_to_id[clean] = val
            id_to_str[counter] = clean
            counter += 1
        return str_to_id[clean]

    def get_name(val):
        try: 
            return id_to_str.get(val.as_long(), str(val))
        except: 
            return str(val)

    # Define Relations
    # has_symptom(Disease/Pest, Symptom/Pest_Manifestation)
    has_symptom = Function('has_symptom', Thing, Thing, BoolSort()) 
    # treated_with(Treatment/Product, Disease/Pest)
    treated_with = Function('treated_with', Thing, Thing, BoolSort()) 
    
    fp.register_relation(has_symptom)
    fp.register_relation(treated_with)

    # Data Holders
    all_symptoms = set()
    all_diseases = set()
    z3_fact_lines = [] 
    
    # --- DataFrames for Visualization Preparation ---
    visualization_data = []

    # --- MODIFIED LOADING LOGIC: READ EXTERNAL CSV ---
    try:
        with open('macadamia_new.csv', mode='r', encoding='utf-8-sig') as f:
            reader = csv.DictReader(f)
            
            for row in reader:
                treatment_name = row.get('Product')
                targets_list_str = row.get('Targets')
                
                if not treatment_name or not targets_list_str: continue 

                t_id = get_id(treatment_name)
                
                for target_raw in targets_list_str.split(','):
                    target_name = target_raw.strip()
                    if not target_name: continue
                    
                    disease_name = target_name.title()
                    d_id = get_id(disease_name)
                    all_diseases.add(disease_name)
                    
                    symptom_name = target_name.lower()
                    s_id = get_id(symptom_name)
                    all_symptoms.add(symptom_name)
                    
                    # 1. Load Symptom Fact: Disease causes Symptom (for Z3)
                    fp.fact(has_symptom(d_id, s_id))
                    z3_fact_lines.append(f"(rule (has_symptom {d_id.as_long()} {s_id.as_long()}))")

                    # 2. Load Treatment Fact: Treatment cures Disease (for Z3)
                    fp.fact(treated_with(t_id, d_id))
                    z3_fact_lines.append(f"(rule (treated_with {t_id.as_long()} {d_id.as_long()}))")

                    # 3. Collect Data for Visualization DataFrame (df_facts)
                    visualization_data.append({
                        'Treatment': treatment_name,
                        'Target': disease_name, # Using Title-cased for targets in DF
                        'Type': row.get('Type') 
                    })

    except FileNotFoundError:
        # Return None for all values, including the new df_facts
        return None, None, None, None, None, None, None, None, None, None, None
    except KeyError as e:
        st.error(f"Error: Missing required column in CSV. Expected 'Product' and 'Targets', but found error: {e}")
        # Return None for all values, including the new df_facts
        return None, None, None, None, None, None, None, None, None, None, None
    
    # Define Logic Rules (The derivation rule)
    t, d, s = Consts('t d s', Thing)
    fp.declare_var(t, d, s)
    
    # Derived relation: cures_symptom(Treatment, Symptom)
    # Rule: If a Treatment (t) is used for a Disease (d), AND that Disease (d) has a Symptom (s), 
    # THEN that Treatment (t) cures that Symptom (s).
    cures_symptom = Function('cures_symptom', Thing, Thing, BoolSort())
    fp.register_relation(cures_symptom)
    fp.rule(cures_symptom(t, s), [treated_with(t, d), has_symptom(d, s)])

    # GENERATE & SAVE Z3 FILE LOCALLY (Unchanged)
    z3_content = ["; Crop Care Knowledge Base - Z3 Facts", "; Auto-generated by Streamlit App", ""]
    
    z3_content.append("; --- ID MAPPING ---")
    sorted_ids = sorted(id_to_str.items())
    for idx, name in sorted_ids:
        z3_content.append(f"; {idx} = {name}")
    
    z3_content.append("")
    z3_content.append("; --- FACTS ---")
    z3_content.extend(z3_fact_lines)
    
    final_z3_string = "\n".join(z3_content)
    
    # Attempt to save to disk
    try:
        with open("crop_care_facts.z3", "w", encoding="utf-8") as z3_file:
            z3_file.write(final_z3_string)
        file_saved = True
    except:
        file_saved = False

    # Create the DataFrame for visualization
    df_facts = pd.DataFrame(visualization_data)
    
    # Return the new DataFrame along with all existing objects
    return fp, has_symptom, treated_with, cures_symptom, get_id, get_name, sorted(list(all_symptoms)), sorted(list(all_diseases)), Thing, file_saved, df_facts

# --- APP EXECUTION ---
# **UPDATED to capture df_facts**
fp, has_symptom_rel, treated_with_rel, cures_symptom_rel, get_id, get_name, symptoms, diseases, ThingType, file_saved, df_facts = load_kb()

# Handle file not found error gracefully
if not fp:
    st.error("‚ùå **Error:** 'new_fungicide_data.csv' file not found. Please ensure the CSV file is in the same directory as this Python script and has the columns: **'Product'** and **'Targets'**.")
    st.stop()

if file_saved:
    st.toast("Verification file 'crop_care_facts.z3' saved to project folder!")

# Helper to extract clean text from Z3 results (Unchanged)
def parse_results(ans_obj):
    results = set()
    def collect(expr):
        if is_bv_value(expr): 
            results.add(get_name(expr)) 
        for child in expr.children(): collect(child) 
    collect(ans_obj)
    return sorted(list(results))

# --- USER INTERFACE ---
# **UPDATED to include a third tab for Visualization**
tab1, tab2, tab3 = st.tabs(["Symptom Checker (Query Treatments)", "Disease Lookup (Verify Data)", "Data Visualization"])

# TAB 1: SEARCH BY SYMPTOM (The deductive query)
with tab1:
    st.header("Diagnosis and Prescription")
    st.markdown("Select an observable issue/symptom to find the recommended treatments.")
    
    selected_symptom = st.selectbox(
        "I see this symptom or pest:",
        symptoms, 
        index=None, 
        placeholder="Select a symptom or pest (e.g., 'anthracnose', 'aphids')..."
        )

    if st.button("Query Treatments (Z3 Deduce)"):
        st.divider()
        if not selected_symptom:
            st.warning("Please select a symptom first.")
        else:
            s_id = get_id(selected_symptom)
            
            # PRESCRIPTION QUERY: What cures this symptom? (Uses the derived rule)
            t_var = Const('t', ThingType)
            fp.declare_var(t_var)
            cure_result = fp.query(cures_symptom_rel(t_var, s_id))
            
            if cure_result == sat:
                treatments = parse_results(fp.get_answer())
                if treatments:
                    st.success(f"‚úÖ **Recommended Treatments for '{selected_symptom}':**")
                    st.markdown(f"**{', '.join(treatments)}**")
                else:
                    st.info("No specific treatment found for this symptom in the database.")
            else:
                st.warning(f"Z3 reported **{cure_result}**. No cure found via logical deduction for '{selected_symptom}'.")

# TAB 2: SEARCH BY DISEASE (The verification queries)
with tab2:
    st.header("Knowledge Base Verification & Details")
    st.markdown("Select a **Disease/Pest** to view the raw facts (Symptoms and Treatments) associated with it.")
    
    # Note: 'diseases' now contains the Title-cased version of the targets (e.g., 'Anthracnose')
    selected_disease = st.selectbox(
        "Select a Disease or Pest to verify:",
        diseases,
        index=None,
        placeholder="Select a disease..."
        )
        
    if st.button("Get Info (Z3 Verify)"):
        st.divider()
        if not selected_disease:
             st.warning("Please select a disease first.")
             st.stop() 
             
        d_id = get_id(selected_disease)
        
        # 1. SYMPTOMS QUERY (Verification Fact)
        s_var = Const('s', ThingType)
        fp.declare_var(s_var)
        sym_result = fp.query(has_symptom_rel(d_id, s_var))
        
        st.subheader("Symptoms/Manifestations (Input Facts)")
        if sym_result == sat:
            found_symptoms = parse_results(fp.get_answer())
            st.info(f"The knowledge base states that **{selected_disease}** is associated with the following issues:")
            for sym in found_symptoms:
                st.markdown(f"- **{sym.title()}**")
        else:
            st.write("No symptoms recorded in the raw data for this disease.")

        # 2. GET TREATMENTS QUERY (Verification Fact)
        t_var = Const('t', ThingType)
        fp.declare_var(t_var)
        treat_result = fp.query(treated_with_rel(t_var, d_id))
        
        st.subheader("Direct Treatments (Input Facts)")
        if treat_result == sat:
            found_treatments = parse_results(fp.get_answer())
            st.success(f"The knowledge base links these treatments directly to **{selected_disease}**:")
            for treat in found_treatments:
                st.markdown(f"- **{treat}**")
        else:
            st.warning("No direct treatments recorded in the raw data for this disease.")


# --- TAB 3: DATA VISUALIZATION ---
with tab3:
    st.header("Knowledge Base Visuals üìà")
    
    if df_facts is not None and not df_facts.empty:

        # 1. Treatment Versatility Chart (Bar Chart)
        st.subheader("Top 15 Most Versatile Treatments")
        st.markdown("Shows which products target the largest number of unique diseases/pests.")
        
        # Group by treatment and count unique targets
        df_grouped = df_facts.groupby(['Treatment', 'Type'])['Target'].nunique().reset_index(name='Target Count')
        df_grouped = df_grouped.sort_values(by='Target Count', ascending=False).head(15)

        # Create the Altair chart
        chart_bar = alt.Chart(df_grouped).mark_bar().encode(
            # X axis: Treatment, sorted by Target Count descending
            x=alt.X('Treatment:N', sort=alt.EncodingSortField(field="Target Count", op="sum", order='descending'), title="Product"),
            y=alt.Y('Target Count:Q', title="Number of Unique Targets"),
            color=alt.Color('Type:N', scale=alt.Scale(domain=['Fungicide', 'Pesticide'], range=['#5C88DA', '#47A97A'])), # Custom colors
            tooltip=['Treatment', 'Target Count', 'Type']
        ).properties(
            title='Treatments by Number of Unique Targets'
        ).interactive() # Allows zooming and panning

        st.altair_chart(chart_bar, use_container_width=True)
        st.markdown("---")

        # 2. Target vs. Treatment Type Scatter Plot (Distribution Check)
        st.subheader("Targets vs. Treatment Type Distribution")
        st.markdown("Visualizes which targets are commonly linked to which type of product.")

        # Count the number of treatments for each Target/Type combination
        df_distribution = df_facts.groupby(['Target', 'Type']).size().reset_index(name='Treatment Count')

        # Create the Altair chart
        chart_dist = alt.Chart(df_distribution).mark_point(filled=True, size=100).encode(
            # X axis: Target, ordered alphabetically
            x=alt.X('Target:N', sort=None, title="Target / Disease"),
            # Y axis: Treatment Count
            y=alt.Y('Treatment Count:Q', title="Total Treatments Targeting This Issue"),
            # Color by Type (Fungicide/Pesticide)
            color=alt.Color('Type:N', scale=alt.Scale(domain=['Fungicide', 'Pesticide'], range=['#5C88DA', '#47A97A'])), 
            # Size reflects the count, emphasizing common targets
            size=alt.Size('Treatment Count:Q', legend=alt.Legend(title="Count")),
            tooltip=['Target', 'Type', 'Treatment Count']
        ).properties(
            title='Treatment Count per Target, Grouped by Type'
        ).interactive()

        st.altair_chart(chart_dist, use_container_width=True)

    else:
        st.warning("Visualization data could not be loaded. Check your 'new_fungicide_data.csv' file.")
